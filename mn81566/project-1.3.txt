https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/README.md

Ссылка бейджа codeclimate ведёт на демонстрационный репозиторий.

_________________


https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/cli.js#L8

Тут не нужен возврат значения из функции, оно нигде не используется в вызывающем коде.
Кроме того имя функции askName вводит в заблуждение так как по факту функция совершает совсем другие операции:
вывод в консоль, интерактивное взаимодействие с пользователем и возврат значения.
В данном случае можно удалить возврат значения а функцию именовать например глаголом greet()

_________________

https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/evenGame.js#L11
https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/primeGame.js#L18

Тут вы правильно поступили, что приводите вопрос к строковому типу.
Движку нужно передавать готовые данные правильного типа.
Но интерполяция по своему смыслу нужна, чтобы вставить внутрь строки результат какого-либо выражения.
У вас же здесь нет такой задачи, потому что в данном случае к строке надо привести всё выражение,
а для этого (по смыслу!) больше подходит метод toString() или функция String().

_________________

https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/calculatorGame.js#L22

В модулях, вложенные определения (функций/констант) делаются тогда, когда их содержимое зависит от лексического контекста.
Во всех остальных случаях предпочтительно выносить определения на уровень модуля (но не обязательно экспортировать).
Такой код легче читать, проще переиспользовать и по необходимости можно экспортировать и тестировать.
Кроме того, надо понимать, что при каждом вызове вмещающей функции (если вызовы неоднократные)
вложенные определения каждый раз заново переопределяются.
Именно это сейчас и происходит - массив с операторами переопределяется каждый раз заново при вызове функции

_________________

https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/calculatorGame.js#L19
https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/calculatorGame.js#L22

generateCalcGameData, а она вызвается на каждом игровом раунде.
operatorArr - не нужно закладывать тип в имя переменной (речь об arr),
венгерская нотация очень редко используется в современной разработке.
Коллекции, например массивы принято именовать существительными во множественном числе. В данном случае operators

_________________

https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/calculatorGame.js#L23

Магическое число 2 - это зависимость от количества операций.
Если количество операций изменится и забыть поменять это значение - программа будет работать некорректно.
Обращайтесь к массиву с операциями, чтобы получить их количество.
Используйте свойство length для получения длины массива.
Только обратите внимание, что значение максимального индекса должно быть на единицу меньше чем длина самого массива.
По аналогии как вы поступили в игре прогрессия.

_________________

https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/progressionGame.js#L27-L29

Минимальная длина прогрессия определена в константе - 5. Когда должно сработать это условие?

_________________

https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/progressionGame.js#L35

Венгерская нотация. В именах оперируйте сущностями - progression

_________________

https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/progressionGame.js#L19-L23

Венгерская нотация arr, str.

_________________

https://github.com/mn81566/frontend-project-lvl1/blob/222279b95e2b8f0d71ab1381a5264697870931b4/src/games/progressionGame.js#L5

res - функция генерирует и возвращает прогрессию. Так и именуйте данную константу.